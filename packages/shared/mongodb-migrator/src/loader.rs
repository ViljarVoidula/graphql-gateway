use anyhow::{anyhow, Result};
use regex::Regex;
use std::fs;
use std::path::Path;

use crate::{Migration, MigrationRegistry};

/// Dynamic migration loader that discovers migrations from filesystem
pub struct MigrationLoader {
    migrations_dir: String,
    pattern: Regex,
}

impl MigrationLoader {
    /// Create a new migration loader
    ///
    /// # Arguments
    /// * `migrations_dir` - Directory containing migration files
    /// * `pattern` - Regex pattern to match migration files (default: `m(\d+)_.*\.rs`)
    pub fn new(migrations_dir: impl Into<String>, pattern: Option<&str>) -> Result<Self> {
        let pattern = pattern.unwrap_or(r"m(\d+)_.*\.rs$");
        let regex = Regex::new(pattern)?;

        Ok(Self {
            migrations_dir: migrations_dir.into(),
            pattern: regex,
        })
    }

    /// Discover migration files in the directory
    pub fn discover_migration_files(&self) -> Result<Vec<MigrationFileInfo>> {
        let migrations_path = Path::new(&self.migrations_dir);

        if !migrations_path.exists() {
            return Err(anyhow!(
                "Migrations directory does not exist: {}",
                self.migrations_dir
            ));
        }

        let mut migrations = Vec::new();

        for entry in fs::read_dir(migrations_path)? {
            let entry = entry?;
            let file_name = entry.file_name().to_string_lossy().to_string();

            if let Some(captures) = self.pattern.captures(&file_name) {
                if let Some(version_match) = captures.get(1) {
                    if let Ok(version) = version_match.as_str().parse::<u32>() {
                        let file_path = entry.path();
                        let module_name = file_name.trim_end_matches(".rs").to_string();

                        migrations.push(MigrationFileInfo {
                            version,
                            file_name,
                            file_path: file_path.to_string_lossy().to_string(),
                            module_name,
                        });
                    }
                }
            }
        }

        // Sort by version
        migrations.sort_by_key(|m| m.version);

        Ok(migrations)
    }

    /// Generate migration registry code (for compile-time registration)
    /// This is mainly for legacy support - the inventory system is preferred
    pub fn generate_registry_code(&self) -> Result<String> {
        let files = self.discover_migration_files()?;

        let mut code = String::new();
        code.push_str("//! Auto-generated migration registry\n");
        code.push_str("//! This file is generated by the migration loader\n");
        code.push_str("//! NOTE: With inventory-based discovery, this is mainly for reference\n\n");

        // Generate module declarations
        for file in &files {
            code.push_str(&format!("pub mod {};\n", file.module_name));
        }
        code.push('\n');

        // Generate use statements
        code.push_str("use mongodb_migrator::MigrationRegistry;\n\n");

        // Generate registration function
        code.push_str("/// Register all discovered migrations\n");
        code.push_str("/// NOTE: With inventory system, migrations auto-register themselves\n");
        code.push_str("pub fn register_all_migrations() -> MigrationRegistry {\n");
        code.push_str("    // With inventory-based discovery, use:\n");
        code.push_str("    // mongodb_migrator::create_migration_registry().unwrap()\n");
        code.push_str("    \n");
        code.push_str("    // Legacy manual registration:\n");
        code.push_str("    MigrationRegistry::new()\n");

        for file in &files {
            let struct_name = self.infer_struct_name(&file.module_name);
            code.push_str(&format!("        // .register({}::{}::default())\n", file.module_name, struct_name));
        }

        code.push_str("}\n");

        Ok(code)
    }

    /// Infer struct name from module name
    /// Converts snake_case module names to PascalCase struct names
    pub fn infer_struct_name(&self, module_name: &str) -> String {
        // Remove the version prefix (e.g., "m001_" -> "")
        let name_part = if let Some(pos) = module_name.find('_') {
            &module_name[pos + 1..]
        } else {
            module_name
        };

        // Convert snake_case to PascalCase
        name_part
            .split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => {
                        first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase()
                    }
                }
            })
            .collect()
    }

    /// Print discovered migrations for debugging
    pub fn print_discovered_migrations(&self) -> Result<()> {
        let files = self.discover_migration_files()?;

        println!("Discovered {} migration files:", files.len());
        for file in files {
            println!(
                "  v{}: {} -> {}",
                file.version,
                file.file_name,
                self.infer_struct_name(&file.module_name)
            );
        }

        Ok(())
    }

    /// Generate a new migration file template
    pub fn generate_migration_template(&self, version: u32, name: &str) -> Result<String> {
        let struct_name = self.snake_to_pascal_case(name);
        let description = name.replace('_', " ");
        
        let template = format!(r#"use async_trait::async_trait;
use mongodb::{{Database, IndexModel}};
use anyhow::Result;
use bson::doc;

use mongodb_migrator::{{Migration, register_migration}};

/// Migration: {description}
#[derive(Default)]
pub struct {struct_name};

// Auto-register this migration using the inventory system
register_migration!({struct_name});

#[async_trait]
impl Migration for {struct_name} {{
    fn version(&self) -> u32 {{
        {version}
    }}

    fn description(&self) -> &str {{
        "{description}"
    }}

    async fn up(&self, db: &Database) -> Result<()> {{
        tracing::info!("Applying migration {{}}: {{}}", self.version(), self.description());
        
        // TODO: Implement your migration logic here
        // Example:
        // let collection = db.collection::<bson::Document>("your_collection");
        // collection.create_index(
        //     IndexModel::builder()
        //         .keys(doc! {{ "field_name": 1 }})
        //         .build(),
        //     None,
        // ).await?;
        
        tracing::info!("Migration {{}} completed successfully", self.version());
        Ok(())
    }}

    async fn down(&self, db: &Database) -> Result<()> {{
        tracing::info!("Rolling back migration {{}}: {{}}", self.version(), self.description());
        
        // TODO: Implement your rollback logic here
        // Example:
        // let collection = db.collection::<bson::Document>("your_collection");
        // collection.drop_index("field_name_1", None).await?;
        
        tracing::info!("Migration {{}} rollback completed", self.version());
        Ok(())
    }}

    fn estimated_duration(&self) -> Option<std::time::Duration> {{
        // TODO: Estimate how long this migration might take
        Some(std::time::Duration::from_secs(10))
    }}

    fn requires_backup(&self) -> bool {{
        // TODO: Set to true if this migration modifies data in a way that requires backup
        false
    }}
}}
"#);

        Ok(template)
    }

    /// Convert snake_case to PascalCase
    fn snake_to_pascal_case(&self, snake_str: &str) -> String {
        snake_str
            .split('_')
            .map(|word| {
                let mut chars = word.chars();
                match chars.next() {
                    None => String::new(),
                    Some(first) => first.to_uppercase().collect::<String>() + &chars.as_str().to_lowercase(),
                }
            })
            .collect()
    }
}

/// Information about a discovered migration file
#[derive(Debug, Clone)]
pub struct MigrationFileInfo {
    pub version: u32,
    pub file_name: String,
    pub file_path: String,
    pub module_name: String,
}

impl MigrationFileInfo {
    /// Get the inferred struct name for this migration
    pub fn struct_name(&self, loader: &MigrationLoader) -> String {
        loader.infer_struct_name(&self.module_name)
    }
}

/// Runtime migration loader that can dynamically load migrations
/// Note: This requires the migrations to be compiled into the binary
pub struct RuntimeMigrationLoader {
    registry: MigrationRegistry,
}

impl RuntimeMigrationLoader {
    /// Create a new runtime loader with pre-registered migrations
    pub fn new() -> Self {
        Self {
            registry: MigrationRegistry::new(),
        }
    }

    /// Register a migration dynamically
    pub fn register<M: Migration + 'static>(mut self, migration: M) -> Self {
        self.registry = self.registry.register(migration);
        self
    }

    /// Get the final registry
    pub fn build(self) -> MigrationRegistry {
        self.registry
    }
}

impl Default for RuntimeMigrationLoader {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_struct_name_inference() {
        let loader = MigrationLoader::new("test", None).unwrap();

        assert_eq!(loader.infer_struct_name("m001_initial_indexes"), "InitialIndexes");
        assert_eq!(loader.infer_struct_name("m002_add_category_field"), "AddCategoryField");
        assert_eq!(loader.infer_struct_name("m003_create_user_table"), "CreateUserTable");
        assert_eq!(loader.infer_struct_name("m010_complex_migration_name"), "ComplexMigrationName");
    }

    #[test]
    fn test_pattern_matching() {
        let loader = MigrationLoader::new("test", None).unwrap();

        assert!(loader.pattern.is_match("m001_initial_indexes.rs"));
        assert!(loader.pattern.is_match("m123_some_migration.rs"));
        assert!(!loader.pattern.is_match("not_a_migration.rs"));
        assert!(!loader.pattern.is_match("m001_migration.txt"));
    }

    #[test]
    fn test_snake_to_pascal_case() {
        let loader = MigrationLoader::new("test", None).unwrap();

        assert_eq!(loader.snake_to_pascal_case("add_user_indexes"), "AddUserIndexes");
        assert_eq!(loader.snake_to_pascal_case("create_table"), "CreateTable");
        assert_eq!(loader.snake_to_pascal_case("simple"), "Simple");
    }

    #[test]
    fn test_migration_template_generation() {
        let loader = MigrationLoader::new("test", None).unwrap();
        let template = loader.generate_migration_template(5, "add_user_indexes").unwrap();

        assert!(template.contains("pub struct AddUserIndexes"));
        assert!(template.contains("register_migration!(AddUserIndexes)"));
        assert!(template.contains("fn version(&self) -> u32 {\n        5"));
        assert!(template.contains("add user indexes"));
    }
}
